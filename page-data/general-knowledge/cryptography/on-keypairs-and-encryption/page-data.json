{"componentChunkName":"component---src-templates-page-tsx","path":"/general-knowledge/cryptography/on-keypairs-and-encryption","result":{"data":{"page":{"title":"On Keypairs & Encryption","slug":"general-knowledge/cryptography/on-keypairs-and-encryption","description":"Best Of","dateModified":"2019-07-08","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"On Keypairs & Encryption\",\n  \"description\": \"Best Of\",\n  \"priority\": 4,\n  \"date_published\": \"2017-07-05\",\n  \"date_modified\": \"2019-07-08\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This is part of a series where Taylor pull's sweet comments she's made in the hope that they can be useful, searchable, remembered, referenced, and/or aid in the creation of future Knowledge Base posts. These are works in progress. Please excuse the typos, unclear statements, and specific references to previous discussions or the user.\"), mdx(\"hr\", null), mdx(\"p\", null, \"The Ledger (and other hardware wallets) are essentially USB sticks but with really really really really really really hardcore software / firmware / hardware that makes it so your key cannot be accessed or moved, even if your computer is compromised. With a regular USB drive, 1337 h4x0r can pull crazy maneuvers to get the info from it via hardware alone, watching the read / writes, or simply searching for your private key, mnemonic, or keystore file on the USB drive. Ledger / TREZOR are dedicated devices built to prevent all these types of attacks.\"), mdx(\"h2\", {\n    \"id\": \"keypairs--cryptography\"\n  }, \"Keypairs & cryptography\"), mdx(\"p\", null, \"The private key (or keystore file or mnemonic or hardware wallet) is basic cryptography in the end\\u2060\\u2014the same cryptography that is used in all sorts of systems that have been around far longer than cryptocurrencies.\"), mdx(\"p\", null, \"At it's most basic, a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"private key\"), \" can turn into a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public key\"), \" but a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public key\"), \" cannot turn into a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"private key\"), \". However, this public key (via fancy math and really really intense computations) can \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"verify that a specific private key was used to sign the transaction\"), \".\"), mdx(\"p\", null, \"Imagine this: You have a buddy in the other room who says a word. The word either has 1 syllable, 5 syllables, or 20 syllables. You cannot hear \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"what\"), \" he says, but you can easily verify that the word he said was short, medium, or ultra-long. So you \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"know\"), \" what word he said (given there were only 3 choices) even though you don't \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"know the actual word\"), \". Cryptography is a bit like that, except it involves fancy graphs, extreme math, and an almost infinite number of private keys (aka \\\"the word your buddy said\\\").\"), mdx(\"h3\", {\n    \"id\": \"verifying-the-private-key-corresponds-to-public-key\"\n  }, \"Verifying the private key corresponds to public key\"), mdx(\"p\", null, \"So back to your question-ish: \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"If the private key is unlocking the wallet from elsewhere...\")), mdx(\"p\", null, \"It's not actually unlocking from elsewhere. There is no server; the blockchain does not know about your private key or password or address (public key) even. It's not the same as what you are used to with email and facebook and all the new-fangled jazz.\"), mdx(\"p\", null, \"The blockchain simply checks if the transaction you want to send (e.g., \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1 ETH\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0x2a9F48....\"), \" from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0x92fbC3.....\"), \") is valid:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Does the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"from address\"), \" have 1 ETH to send?\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Did the private key pair of that address (the public key) sign the transaction?\")), mdx(\"p\", null, \"I could sign a transaction saying \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0x92fbC3.....\"), \" wants to send \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1 ETH\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0x2a9F48....\"), \" with any key I wanted to. I could just make it up off the top of my head. But it would fail check #2, and therefore never be accepted into the blockchain, and therefore the funds (which are your funds) would never move.\"), mdx(\"p\", null, \"The only way to move funds is to send those funds with a transaction signed by the private key that corresponds to the address you are sending from. And the amount of private keys available is so insanely large that it would take literal eons to ever be able to guess someone else's private key. It's quite simple. (\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/staying-safe/couldnt-everybody-put-in-a-random-key-and-send-to-own-address\"\n  }), \"More on that here if you are interested\"), \")\"), mdx(\"h3\", {\n    \"id\": \"fancy-keys-passwords--encryption\"\n  }, \"Fancy keys, passwords & encryption\"), mdx(\"p\", null, \"Okay bear with me one more thing.\"), mdx(\"p\", null, \"Private keys can be fancy: They can be keystore files (which are encrypted with a password) or mnemonic phrases (which can be encrypted with a password, are easier to read, and give you access to multiple addresses / accounts / keypairs).\"), mdx(\"p\", null, \"When we say encrypted we mean that you must do something first, before you can use the private key to sign the transaction. Encryption works like this:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"You take \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"7\"), \" (your private key) and you multiply it by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"10\"), \" (your password) which outputs \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"70\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"70\"), \" is now your encrypted key\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"You can't use \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"70\"), \" to sign a transaction because it's gibberish\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"You can take \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"70\"), \" and divide it by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"10\"), \" in order to get \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"7\"), \". But you can't figure out what \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"7\"), \" is unless you have that secondary piece of information (your password / \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"10\"), \"). \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"7 x 10 = 70\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"70 / 10 = 7\"), \" but if you only have 70, you have an infinite number of possibilities for the private key and password: It could be \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"14 x 5\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"9 x 7.777777778\"), \" and on and on.\")), mdx(\"p\", null, \"Again, there is no server verifying your password or private key. It's all done by your computer and all it knows is that it's either correct or incorrect by trying it:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"if you take \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"70\"), \" and divide it by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"8\"), \", you get \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"8.75\"), \", which is not the private key for the public key you want to send from.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"if you take \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"70\"), \" and divide it by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0\"), \", the world ends bc you can't divide by 0, silly.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"if you take \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"70\"), \" and divide it by \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"80000\"), \", you get \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"0.000875\"), \" which is way too small to be a private key.\")), mdx(\"p\", null, \"...and so forth and so forth. When you give it the correct password, it gets a valid private key and can sign the transaction, which can then be put on the blockchain, and you successfully sent your ETH.\"), mdx(\"p\", null, \"I hope this helps somewhat. I know it's long and probably confusing, but come back and re-read it in a week or month and see how much more you grok.\"), mdx(\"h2\", {\n    \"id\": \"source\"\n  }, \"Source\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://www.reddit.com/r/MyEtherWallet/comments/6vm6xa/moron_question_why_the_wallet/dm3ntq9/\",\n    \"target\": \"_blank\",\n    \"rel\": \"noopener noreferrer\"\n  }), \"https://www.reddit.com/r/MyEtherWallet/comments/6vm6xa/moron_question_why_the_wallet/dm3ntq9/\"))));\n}\n;\nMDXContent.isMDXComponent = true;"},"parent":{"__typename":"Category","title":"Cryptography & Encryption","slug":"general-knowledge/cryptography"}}},"pageContext":{"slug":"general-knowledge/cryptography/on-keypairs-and-encryption"}}}